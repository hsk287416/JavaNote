# 1. 单块架构

## 1.1 示意图

![avatar](https://raw.githubusercontent.com/hsk287416/JavaNote/master/imgs/2018-06-16_160321.png)


## 1.2 优缺点

- 优点：
    - 功能划分清楚
    - 层次关系良好
    - 每一层独立
    - 部署简单
    - 技术单一（基本来说，每一层只用一种开发语言）
- 缺点：
    - 功能划分粒度太大
    - 升级风险高。比如说，一个单块架构项目中包含了4个服务，当我们需要为其中1个服务做升级的时候，都不得不升级整个系统。
    - 维护成本增加。当一个项目越来越庞大的时候，维护起来非常麻烦。
    - 交付周期变长。
    - 可伸缩性差。
    - 监控困难。

# 2. SOA微服务架构

一个系统在创建的时候都会倾向于内聚，也就是说把所有的功能都累加到一起，这是非常自然的。当随着系统慢慢壮大之后，单块架构就会变得无法承受当初的一个技术架构，这个时候就需要演变和进化。

SOA微服务架构就是把整个项目打散成不同的服务模块（高内聚低耦合），模块之间通过网络联系。所以SOA可以跨语言、跨平台的开发系统。

## 2.1 微服务架构的设计原则

- 拆分足够微，而又不至于太小
- 轻量级通信。同步通信可以采用REST+JSON，异步通信可以采用消息中间件
- 单一职责原则。服务功能高内聚，开发人员职责单一
- 不限于技术栈
- 领域驱动原则

> **什么是领域？**
```text
我们所做的软件系统的目的都是来解决一系列问题，例如做一个电商系统来在线销售自己企业的产品；做一个灰度发布平台来提升服务的质量和稳定性。任何一个系统都会属于某个特定的领域，例如：

论坛是一个领域：要做一个论坛，那这个论坛的核心业务是确定的：比如用户发帖、回帖等核心基本功能；
电商系统是一个领域：只要是电商领域的系统，那核心业务就是：商品浏览、购物车、下单、减库存、付款交易等核心环节；
同一个领域的系统都具有相同的核心业务，因为他们要解决的问题的本质是类似的。因此可以推断：一个领域本质上可以理解为一个 问题域 。只要确定了系统所属的领域，那么这个系统的核心业务，即要解决的关键问题就基本确定了。通常我们说，要成为一个领域的专家，必须要在这个领域深入研究很多年才行，只有这样才会遇到非常多的该领域的问题，积累了丰富的经验。
```
参见：[https://www.cnblogs.com/butterfly100/p/7827870.html](https://www.cnblogs.com/butterfly100/p/7827870.html)

## 2.2 设计微服务是要考虑的话题
1. 服务拆分
2. 服务注册。有一个服务注册中心，当有微服务启动的时候，就会到服务注册中心进行注册。然后通过心跳感知进行状态联系。
3. 服务发现。通过服务注册中心去发现服务
4. 服务消费。调用别的服务
5. 统一入口
6. 配置管理
7. 熔断机制。熔断机制的作用是，当系统出现请求堆积而无法响应的时候，阻断无法处理的请求，以防止服务器的崩溃。
8. 自动扩展。当请求数量突然增加，当前服务器实例数量无法处理的时候，可以自动创建服务器实例来应对请求。

# 3. 微服务的协调者 -- Spring Cloud

Spring Cloud提供的功能：
1. 配置管理
2. 服务注册
3. 服务发现
4. 服务间调用
5. 断路器
6. 智能路由
7. 负载均衡
8. 微代理
9. 一次性令牌
10. 控制总线
11. 全局锁
12. 分布式会话
13. 集群状态&领导选举
14. 分布式消息

## 3.1 使用Eureka实现服务注册和服务发现

### 3.1.1 创建Eureka服务器
使用Spring Initializr创建Spring Cloud项目，在添加依赖时选择 **Cloud Discovery => Eureka Server** 。项目创建完成之后的的 ***pom.xml*** 文件如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.spring.cloud</groupId>
    <artifactId>micro-weather-eureka-server</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>项目名</name>
    <description>项目描述</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.3.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
        <spring-cloud.version>Finchley.RC2</spring-cloud.version>
    </properties>

    <dependencies>
        <!-- eureka-server依赖 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
             <!-- spring cloud依赖 -->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

    <!-- 添加仓储 -->
    <repositories>
        <repository>
            <id>spring-milestones</id>
            <name>Spring Milestones</name>
            <url>https://repo.spring.io/milestone</url>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>
    </repositories>
</project>
```

然后，需要修改一下 ***application.yml*** 文件，如下：
```yml
server:
  port: 8761
eureka:
  instance:
    hostname: localhost
  client:
    register-with-eureka: false
    fetch-registry: false
    service-url:
      default-zone: http://${eureka.instance.hostname}:${server.port}/eureka/
```

最后，在main方法所在文件上加入以下注解
```java
@SpringBootApplication
@EnableEurekaServer // 使该项目作为EurekaServer而存在
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

当以上配置完成之后，运行项目，访问 **http://localhost:8761/** 就可以用网页视图看到EurekaServer的状态。

### 3.1.1 创建Eureka客户端

使用Spring Initializr创建Spring Cloud项目，在添加依赖时选择 **Cloud Discovery => Eureka Discovery** 。项目创建完成之后的的 ***pom.xml*** 文件如下：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>com.spring.cloud</groupId>
	<artifactId>micro-weather-eureka-client</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>项目名</name>
	<description>项目说明</description>

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.0.3.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
		<java.version>1.8</java.version>
		<spring-cloud.version>Finchley.RC2</spring-cloud.version>
	</properties>

	<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

	<repositories>
		<repository>
			<id>spring-milestones</id>
			<name>Spring Milestones</name>
			<url>https://repo.spring.io/milestone</url>
			<snapshots>
				<enabled>false</enabled>
			</snapshots>
		</repository>
	</repositories>
</project>
```

然后，需要修改一下 ***application.yml*** 文件，如下：
```yml
spring:
  application:
    name: micro-weather-eureka-client
eureka:
  client:
    service-url:
      default-zone: http://localhost:8761/eureka/   #这里的URL是Eureka服务器的URL地址
```

最后，在main方法所在文件上加入以下注解
```java
@SpringBootApplication
@EnableDiscoveryClient  //作为EurekaClient而存在
public class Application {
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}
```

当以上配置完成之后，运行项目，访问 **http://localhost:8761/** 就可以用网页视图看到EurekaClient已经添加到EurekaServer中了。

# 4. 微服务的消费模式

## 4.1 服务直连模式
我们访问一个URL，从而获取某些资源，这种方式就叫做服务直连模式。

**优点：**

1. 简洁明了
2. 平台语言无关

**缺点：**

1. 无法保证服务的可用性（一旦服务器宕机，我们就无法获取资源了）
2. 生产环境中比较少用

## 4.2 客户端发现模式
首先，服务实例启动后，将自己的位置信息提交到服务注册中心。

然后，客户端从服务注册中心进行查询，来获取可用的服务实例。

最后，客户端自行使用负载均衡算法从多个服务实例中选择出一个。

这种模式就叫做客户端发现模式。

![avatar](https://raw.githubusercontent.com/hsk287416/JavaNote/master/imgs/2018-06-18_053657.png)

## 4.3 服务端发现模式

服务端发现模式与客户端发现模式最主要的区别就是，在服务端发现模式中，服务均衡是由服务端方面实现的。

